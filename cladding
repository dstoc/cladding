#!/bin/sh
set -e

resolve_script_path() {
  case "$1" in
    */*) printf '%s\n' "$1" ;;
    *) command -v -- "$1" ;;
  esac
}

SCRIPT_PATH="$(resolve_script_path "$0")"
if command -v readlink >/dev/null 2>&1; then
  SCRIPT_PATH="$(readlink -f "$SCRIPT_PATH" 2>/dev/null || printf '%s' "$SCRIPT_PATH")"
fi
case "$SCRIPT_PATH" in
  /*) ;;
  *) SCRIPT_PATH="$(pwd)/$SCRIPT_PATH" ;;
esac
CLADDING_ROOT="$(CDPATH= cd -- "$(dirname -- "$SCRIPT_PATH")" && pwd)"

print_help() {
  cat <<'EOF'
Usage: cladding <command> [args...]

Commands:
  build                Build local container images
  init                 Create config and default mount directories
  check                Check requirements
  up                   Start the system
  down                 Stop the system
  destroy              Force-remove running containers
  run                  Run a command in the cli container
  reload-proxy         Reload the squid proxy configuration
  help                 Show this help
EOF
}

find_project_root() {
  search_dir="$PWD"

  while :; do
    if [ -d "$search_dir/.cladding" ]; then
      printf '%s\n' "$search_dir/.cladding"
      return 0
    fi

    if [ "$search_dir" = "/" ]; then
      return 1
    fi

    search_dir="$(dirname -- "$search_dir")"
  done
}

cmd_build() {
  HOST_UID="$(id -u)"
  HOST_GID="$(id -g)"
  TOOLS_DIR="$PROJECT_ROOT/tools"
  TOOLS_BIN_DIR="$TOOLS_DIR/bin"

  if [ -L "$TOOLS_DIR" ] && [ ! -e "$TOOLS_DIR" ]; then
    echo "missing: tools (broken symlink at $TOOLS_DIR)" >&2
    echo "hint: create or relink $TOOLS_DIR" >&2
    return 1
  fi

  mkdir -p "$TOOLS_BIN_DIR"

  podman run --rm \
    -e CARGO_TARGET_DIR=/work/mcp-run/target \
    -v "$CLADDING_ROOT/mcp-run:/work/mcp-run" \
    -w /work/mcp-run \
    docker.io/library/rust:latest \
    cargo build --manifest-path /work/mcp-run/Cargo.toml --release --locked --bin mcp-run --bin run-remote

  install -m 0755 "$CLADDING_ROOT/mcp-run/target/release/mcp-run" "$TOOLS_BIN_DIR/mcp-run"
  install -m 0755 "$CLADDING_ROOT/mcp-run/target/release/run-remote" "$TOOLS_BIN_DIR/run-with-network"

  podman build \
    --build-arg UID="$HOST_UID" \
    --build-arg GID="$HOST_GID" \
    -t localhost/gemini-cli:latest \
    -f "$CLADDING_ROOT/Containerfile.gemini" \
    "$CLADDING_ROOT"

  podman build \
    --build-arg UID="$HOST_UID" \
    --build-arg GID="$HOST_GID" \
    -t localhost/mcp-run-sandbox:latest \
    -f "$CLADDING_ROOT/Containerfile.sandbox" \
    "$CLADDING_ROOT"
}

check_required_paths() {
  missing=0

  for name in config home tools; do
    path="$PROJECT_ROOT/$name"

    if [ -L "$path" ]; then
      if [ ! -e "$path" ]; then
        echo "missing: $name (broken symlink at $path)" >&2
        if [ "$name" = "config" ]; then
          echo "hint: run cladding init" >&2
        else
          echo "hint: create or relink $path" >&2
        fi
        missing=1
      fi
      continue
    fi

    if [ ! -e "$path" ]; then
      echo "missing: $name ($path)" >&2
      if [ "$name" = "config" ]; then
        echo "hint: run cladding init" >&2
      else
        echo "hint: mkdir -p $path (or symlink it)" >&2
      fi
      missing=1
    fi
  done

  if [ "$missing" -ne 0 ]; then
    return 1
  fi
}

check_required_binaries() {
  missing=0

  for name in mcp-run run-with-network; do
    path="$PROJECT_ROOT/tools/bin/$name"

    if [ ! -x "$path" ]; then
      echo "missing: tools/bin/$name ($path)" >&2
      echo "hint: run cladding build" >&2
      missing=1
    fi
  done

  if [ "$missing" -ne 0 ]; then
    return 1
  fi
}

check_required_images() {
  missing=0

  for image in localhost/gemini-cli:latest localhost/mcp-run-sandbox:latest; do
    if ! podman image exists "$image"; then
      echo "missing: image $image (run: cladding build)" >&2
      missing=1
    fi
  done

  if [ "$missing" -ne 0 ]; then
    return 1
  fi
}

cmd_init() {
  src="$CLADDING_ROOT/config-template"
  dst="$PROJECT_ROOT/config"

  if [ -e "$PROJECT_ROOT" ] && [ ! -d "$PROJECT_ROOT" ]; then
    echo "error: .cladding path exists but is not a directory: $PROJECT_ROOT" >&2
    return 1
  fi

  mkdir -p "$PROJECT_ROOT"

  if [ ! -d "$src" ]; then
    echo "missing: config-template ($src)" >&2
    return 1
  fi

  if [ -e "$dst" ] || [ -L "$dst" ]; then
    echo "config already exists: $dst"
  else
    cp -a "$src" "$dst"
    echo "initialized: $dst"
  fi
}

cmd_check() {
  check_required_paths
  check_required_binaries
  check_required_images
  echo "check: ok"
}

resolve_network_settings() {
  NETWORK="${CLADDING_NETWORK:-secure_net}"
  NETWORK_SUBNET="${CLADDING_NETWORK_SUBNET:-10.90.0.0/24}"
  PROXY_IP="${CLADDING_PROXY_IP:-10.90.0.10}"
  SANDBOX_IP="${CLADDING_SANDBOX_IP:-10.90.0.11}"
  CLI_IP="${CLADDING_CLI_IP:-10.90.0.12}"
}

render_pods_yaml() {
  sed \
    -e "s|PROJECT_ROOT|$PROJECT_ROOT|g" \
    -e "s|CLADDING_ROOT|$CLADDING_ROOT|g" \
    -e "s|REPLACE_PROXY_IP|$PROXY_IP|g" \
    -e "s|REPLACE_SANDBOX_IP|$SANDBOX_IP|g" \
    -e "s|REPLACE_CLI_IP|$CLI_IP|g" \
    "$CLADDING_ROOT/pods.yaml"
}

cmd_up() {
  check_required_paths
  check_required_binaries
  check_required_images

  resolve_network_settings

  if ! podman network exists "$NETWORK"; then
    podman network create --subnet "$NETWORK_SUBNET" "$NETWORK"
  elif ! podman network inspect "$NETWORK" | grep -q "\"subnet\": \"$NETWORK_SUBNET\""; then
    echo "error: network $NETWORK exists but is not on $NETWORK_SUBNET" >&2
    echo "hint: set CLADDING_NETWORK_SUBNET to match, or run 'podman network rm $NETWORK' and retry './cladding up'" >&2
    return 1
  fi

  render_pods_yaml | podman play kube \
      --network "$NETWORK" \
      --ip "$PROXY_IP" \
      --ip "$SANDBOX_IP" \
      --ip "$CLI_IP" \
      -
}

cmd_down() {
  resolve_network_settings
  render_pods_yaml | podman play kube --down -
}

cmd_destroy() {
  podman rm -f cli-pod sandbox-pod proxy-pod
}

cwd_relative_to_project_root() {
  project_dir="$(dirname -- "$PROJECT_ROOT")"

  if command -v realpath >/dev/null 2>&1; then
    realpath --relative-to="$project_dir" "$PWD"
    return 0
  fi

  case "$PWD" in
    "$project_dir")
      printf '%s\n' "."
      ;;
    "$project_dir"/*)
      printf '%s\n' "${PWD#$project_dir/}"
      ;;
    *)
      return 1
      ;;
  esac
}

cmd_run() {
  if [ $# -eq 0 ]; then
    echo "usage: cladding run <command> [args...]" >&2
    return 1
  fi

  if workdir_rel="$(cwd_relative_to_project_root)"; then
    container_workdir="/home/user/workspace"
    if [ "$workdir_rel" != "." ]; then
      container_workdir="$container_workdir/$workdir_rel"
    fi
  else
    project_dir="$(dirname -- "$PROJECT_ROOT")"
    echo "error: could not determine current path relative to project dir ($project_dir): $PWD" >&2
    echo "hint: run cladding from $project_dir or one of its subdirectories" >&2
    return 1
  fi

  exec podman exec -it \
    -w "$container_workdir" \
    --env TERM="${TERM:-xterm-256color}" \
    --env COLORTERM="${COLORTERM:-truecolor}" \
    --env FORCE_COLOR="${FORCE_COLOR:-3}" \
    cli-pod-cli-app \
    "$@"
}

cmd_reload_proxy() {
  podman exec proxy-pod-proxy squid -k reconfigure -f /tmp/squid_generated.conf
}

if [ $# -eq 0 ]; then
  cmd="help"
else
  cmd="$1"
  shift
fi

if PROJECT_ROOT="$(find_project_root)"; then
  :
else
  case "$cmd" in
    help|-h|--help)
      ;;
    init)
      PROJECT_ROOT="$PWD/.cladding"
      ;;
    *)
      echo "error: no .cladding directory found in $PWD or any parent directory" >&2
      echo "hint: run 'cladding init' from the project directory to create one" >&2
      exit 1
      ;;
  esac
fi

case "$cmd" in
  build)
    cmd_build "$@"
    ;;
  init)
    cmd_init "$@"
    ;;
  check)
    cmd_check "$@"
    ;;
  up)
    cmd_up "$@"
    ;;
  down)
    cmd_down "$@"
    ;;
  destroy)
    cmd_destroy "$@"
    ;;
  run)
    cmd_run "$@"
    ;;
  reload-proxy)
    cmd_reload_proxy "$@"
    ;;
  help|-h|--help)
    print_help
    ;;
  *)
    echo "Unknown command: $cmd" >&2
    echo >&2
    print_help >&2
    exit 1
    ;;
esac
